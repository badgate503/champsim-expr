<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>实验结果可视化</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@4.1.1/dist/chartjs-plugin-annotation.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f8f9fa; }
        h1 { color: #333; }
        #fileList { margin-bottom: 20px; }
        canvas { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; }
    </style>
</head>
    </script>

    
</body>
    
    <h2>所有实验结果堆叠条形图</h2>
    <div style="margin-bottom:10px;text-align:center">
        <label style="font-size:16px;font-weight:bold;">筛选 Set：</label>
        <span id="setFilterBox"></span>
    </div>
    <div style="width:100%;max-width:100%;display:block;">
        <canvas id="barChart" height="800" style="width:100%"></canvas>
    </div>
    

    
    <div hidden id="fileList"></div>
    <div hidden><canvas hidden id="pieChart" width="600" height="400"></canvas></div>
    <div style="margin-top:40px;text-align:center">
        <div id="flowTitle" style="font-size:20px;font-weight:bold;margin-bottom:10px;">Miss 原因分类</div>
        <canvas id="flowCanvas" width="1400" height="700" style="width:90vw;max-width:1200px;height:700px;border:1px solid #ccc;background:#fff;"></canvas>
        <script>
        // stack bar 颜色映射
        const reasonColors = {
            'TARGET_FIRST_APPEAR': '#FF6384',
            'PF_TOO_LATE': '#36A2EB',
            'NO_TRIGGER': '#FFCE56',
            'NO_MD_LAST_ADDR_0': '#4BC0C0',
            'NO_MD_LAST_ADDR_REPEAT': '#9966FF',
            'PF_TOO_EARLY': '#FF9F40',
            'EVICTED_MD_CAPACITY': '#C9CBCF',
            'EVICTED_MD_CONFLICT': '#B2DFDB',
            'Capacity': '#C9CBCF',
            'Conflict': '#B2DFDB',
            'Last = 0': '#4BC0C0',
            'Last = Cur': '#9966FF',
        };

        // 统计当前 trace 的各原因数量
        async function getReasonCounts(filename) {
            const resp = await fetch(`/result_data?file=${encodeURIComponent(filename)}`);
            const text = await resp.text();
            const lines = text.trim().split(/\r?\n/);
            const counts = {};
            for (const line of lines) {
                const [k, v] = line.split(/\s+/);
                if (k && v) counts[k] = Number(v);
            }
            // 合成 Capacity/Conflict/Last=0/Last=Cur
            counts['Capacity'] = (counts['EVICTED_MD_CAPACITY']||0);
            counts['Conflict'] = (counts['EVICTED_MD_CONFLICT']||0);
            counts['Last = 0'] = (counts['NO_MD_LAST_ADDR_0']||0);
            counts['Last = Cur'] = (counts['NO_MD_LAST_ADDR_REPEAT']||0);
            return counts;
        }

        // 绘制流程图，reasonCounts 为各原因数量
        function drawUserFlowGraph(reasonCounts) {
            const ctx = document.getElementById('flowCanvas').getContext('2d');
            ctx.clearRect(0,0,1400,700);
            ctx.save();
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            function node(x, y, w, h, text, shape, opts={}) {
                ctx.save();
                ctx.beginPath();
                if (shape==='diamond') {
                    ctx.moveTo(x, y-h/2); ctx.lineTo(x+w/2, y); ctx.lineTo(x, y+h/2); ctx.lineTo(x-w/2, y); ctx.closePath();
                } else {
                    ctx.roundRect ? ctx.roundRect(x-w/2, y-h/2, w, h, 10) : ctx.rect(x-w/2, y-h/2, w, h);
                }
                let fill = opts.fill;
                if (!fill && reasonColors[text]) fill = reasonColors[text];
                ctx.strokeStyle = opts.stroke || '#333';
                ctx.lineWidth = opts.bold ? 2.5 : 1.5;
                ctx.stroke();
                ctx.fillStyle = fill || '#fff';
                ctx.fill();
                ctx.fillStyle = opts.text || '#222';
                let lines = text.split(/\n/);
                let font0 = ctx.font;
                if (opts.bold) ctx.font = 'bold 17px sans-serif';
                lines.forEach((line,i)=>ctx.fillText(line, x, y-(lines.length-1)*12+i*24));
                ctx.font = font0;
                // 数量数字
                if (reasonCounts && reasonCounts[text] !== undefined) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#d32f2f';
                    ctx.fillText(reasonCounts[text], x, y+h/2+20);
                }
                ctx.restore();
            }
            function arrow(x1, y1, x2, y2, label) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.strokeStyle = '#444'; ctx.lineWidth = 1.5; ctx.stroke();
                let dx = x2-x1, dy = y2-y1, len = Math.sqrt(dx*dx+dy*dy);
                if (len>0) {
                    let ux = dx/len, uy = dy/len;
                    let px = x2-ux*12, py = y2-uy*12;
                    ctx.beginPath();
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(px-uy*5, py+ux*5);
                    ctx.lineTo(px+uy*5, py-ux*5);
                    ctx.closePath();
                    ctx.fillStyle = '#444';
                    ctx.fill();
                }
                if (label) {
                    ctx.fillStyle = '#1976d2';
                    ctx.font = 'bold 15px sans-serif';
                    ctx.fillText(label, (x1+x2)/2, (y1+y2)/2);
                }
                ctx.restore();
            }
            // 坐标
            const X = 700, Y = 70, DX = 210, DY = 90;
            node(X, Y, 170, 40, 'L2 Cache Miss', 'rect', {bold:true,fill:'#f8f9fa'});
            arrow(X, Y+20, X, Y+DY-25);
            node(X, Y+DY, 170, 50, 'Addr first appear?', 'diamond', {bold:true});
            arrow(X+85, Y+DY, X+DX, Y+DY, 'YES');
            node(X+DX+100, Y+DY, 200, 38, 'TARGET_FIRST_APPEAR', 'rect');
            arrow(X, Y+DY+25, X, Y+2*DY-25, 'NO');
            node(X, Y+2*DY, 170, 50, 'In MSHR/PQ?', 'diamond', {bold:true});
            arrow(X+85, Y+2*DY, X+DX, Y+2*DY, 'YES');
            node(X+DX+60, Y+2*DY, 130, 38, 'PF_TOO_LATE', 'rect');
            arrow(X, Y+2*DY+25, X, Y+3*DY-25, 'NO');
            node(X, Y+3*DY, 200, 50, 'Added Last,Cur before?', 'diamond', {bold:true});
            arrow(X+100, Y+3*DY, X+DX+30, Y+3*DY+DY, 'YES');

            node(X+DX+110, Y+4*DY, 150, 50, 'Still in MD?', 'diamond', {bold:true});
            arrow(X+DX+185, Y+4*DY, X+DX+300, Y+4*DY, 'YES');
            node(X+DX+370, Y+4*DY, 130, 38, 'PF_TOO_EARLY', 'rect');
            arrow(X+DX+110, Y+4*DY+25, X+DX+110, Y+5*DY-25, 'NO');
            node(X+DX+110, Y+5*DY, 150, 50, 'Why Evicted?', 'diamond', {bold:true});

            arrow(X+DX+190, Y+5*DY, X+DX+310, Y+5*DY);
            node(X+DX+370, Y+5*DY, 100, 38, 'Capacity', 'rect');
            arrow(X+DX+190, Y+5*DY, X+DX+310, Y+5*DY+80);
            node(X+DX+370, Y+5*DY+80, 100, 38, 'Conflict', 'rect');


            arrow(X-100, Y+3*DY, X-190, Y+4*DY, 'NO');

            node(X-290, Y+4*DY, 200, 50, 'Added X,Cur Before?', 'diamond', {bold:true});
            arrow(X-390, Y+4*DY, X-500, Y+4*DY, 'YES');
            node(X-570, Y+4*DY, 130, 38, 'NO_TRIGGER', 'rect');
            arrow(X-290, Y+4*DY+25, X-290, Y+5*DY-25, 'NO');
            node(X-290, Y+5*DY, 150, 50, 'Why Not?', 'diamond', {bold:true});

            
            arrow(X-370, Y+5*DY, X-480, Y+5*DY);
            node(X-540, Y+5*DY, 100, 38, 'Last = 0', 'rect');
            arrow(X-370, Y+5*DY, X-480, Y+5*DY+80);
            node(X-540, Y+5*DY+80, 100, 38, 'Last = Cur', 'rect');
            ctx.restore();
        }

        // 记录 result 文件列表
        let resultFiles = [];
        fetch('/result_list').then(r=>r.json()).then(list=>{resultFiles=list;});

        // 当前流程图 trace 文件名
        let flowCurrentFile = null;

        // 切换 trace 或初始加载时刷新流程图
        async function refreshFlowGraph(traceName) {
            let file = resultFiles[0];
            let showName = '';
            if (traceName) {
                // traceName 可能是无后缀名
                let match = resultFiles.find(f => f.replace(/_breif\.txt$/i,'').replace(/\.txt$/i,'') === traceName);
                if (match) file = match;
                showName = traceName;
            } else if (file) {
                showName = file.replace(/_breif\.txt$/i,'').replace(/\.txt$/i,'');
            }
            flowCurrentFile = file;
            const counts = await getReasonCounts(file);
            drawUserFlowGraph(counts);
            // 更新标题
            document.getElementById('flowTitle').textContent = showName ? `${showName} 的 Miss 原因分类` : 'Miss 原因分类';
        }
    </script>
    </div>
    
    <script>
        async function fetchResultFiles() {
            // 这里假设有一个后端API /result_list 返回文件名列表
            const resp = await fetch('/result_list');
            return await resp.json();
        }
        async function fetchResultData(filename) {
            // 这里假设有一个后端API /result_data?file=xxx 返回文件内容
            const resp = await fetch(`/result_data?file=${encodeURIComponent(filename)}`);
            return await resp.text();
        }
        function parseResultData(text) {
            // 解析每行: "KEY VALUE"
            const lines = text.trim().split(/\r?\n/);
            const labels = [], data = [];
            for (const line of lines) {
                const [k, v] = line.split(/\s+/);
                if (k && v) {
                    labels.push(k);
                    data.push(Number(v));
                }
            }
            return { labels, data };
        }
        function renderPieChart(labels, data, traceName) {
            if (window.pieChartObj) window.pieChartObj.destroy();
            const ctx = document.getElementById('pieChart').getContext('2d');
            window.pieChartObj = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#C9CBCF', '#B2DFDB', '#F06292', '#FFD54F', '#81C784', '#BA68C8'
                        ],
                    }]
                },
                options: {
                    responsive: false,
                    plugins: {
                        legend: { position: 'right' },
                        title: { display: true, text: (traceName ? `${traceName} 的 Miss 原因分布` : '各类Miss原因分布') }
                    }
                }
            });
            // 切换 trace 时刷新流程图数字
            if (traceName) refreshFlowGraph(traceName);
        }
        async function fetchTracelist() {
            const resp = await fetch('/tracelist');
            return await resp.text();
        }

        function parseTracelist(text) {
            // 返回 {setName: [trace, ...], ...}
            const sets = {};
            text.split(/\r?\n/).forEach(line => {
                if (!line.trim()) return;
                const [set, traces] = line.split(':');
                if (set && traces) {
                    sets[set.trim()] = traces.trim().split(/\s+/).sort();
                }
            });
            return sets;
        }

        // set 过滤器控件逻辑（checkbox 版）
        let allSets = [];
        let selectedSets = [];

        function renderSetFilter(sets) {
            allSets = sets;
            const box = document.getElementById('setFilterBox');
            box.innerHTML = '';
            sets.forEach(s => {
                const id = 'setcb_' + s.replace(/[^\w]/g,'_');
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = s;
                cb.id = id;
                cb.checked = true;
                cb.style.margin = '0 6px 0 12px';
                cb.onchange = function() {
                    selectedSets = Array.from(box.querySelectorAll('input[type=checkbox]:checked')).map(c=>c.value);
                    if (window.lastBarFiles) renderBarChart(window.lastBarFiles, true);
                };
                const label = document.createElement('label');
                label.htmlFor = id;
                label.textContent = s;
                label.style.marginRight = '8px';
                box.appendChild(cb);
                box.appendChild(label);
            });
            selectedSets = sets.slice();
        }

        // 修改 renderBarChart 支持 set 过滤
        async function renderBarChart(files, isFilterChange) {
            // 读取 tracelist
            let tracelistText = '';
            try {
                tracelistText = await fetchTracelist();
            } catch (e) {
                alert('无法加载 tracelist，分组功能不可用！');
                return;
            }
            const sets = parseTracelist(tracelistText);
            // 渲染 set 过滤器（仅首次或 set 变化时）
            if (!isFilterChange) renderSetFilter(Object.keys(sets));
            // 反查 trace->set
            const trace2set = {};
            Object.entries(sets).forEach(([set, arr]) => arr.forEach(t => trace2set[t] = set));
            // 只保留 result 里有的 trace
            // 去掉 _breif.txt 后缀再和 tracelist 匹配
            // 支持 _breif.txt、.txt 后缀，忽略大小写
            const fileMap = {};
            files.forEach(f => {
                let key = f;
                if (key.endsWith('_breif.txt')) key = key.slice(0, -10);
                else if (key.endsWith('.txt')) key = key.slice(0, -4);
                key = key.toLowerCase();
                fileMap[key] = f;
            });
            // 只保留选中 set
            let filterSet = selectedSets && selectedSets.length ? selectedSets : Object.keys(sets);
            const grouped = [];
            Object.entries(sets).forEach(([set, arr]) => {
                if (!filterSet.includes(set)) return;
                const traces = arr.filter(t => fileMap[t.toLowerCase()]);
                if (traces.length) grouped.push({ set, traces });
            });
            // 展平 trace 顺序
            // 还原为 result 文件名顺序
            const orderedTraces = grouped.flatMap(g => g.traces);
            if (orderedTraces.length === 0) {
                alert('没有可用的 trace 数据，或 result 文件名与 tracelist 不匹配！');
                return;
            }
            // 读取所有文件内容
            const allData = [];
            let allLabels = new Set();
            for (const t of orderedTraces) {
                const f = fileMap[t.toLowerCase()];
                try {
                    const text = await fetchResultData(f);
                    const { labels, data } = parseResultData(text);
                    allData.push({ file: t, labels, data });
                    labels.forEach(l => allLabels.add(l));
                } catch (e) {
                    console.warn('无法加载结果文件:', f);
                }
            }
            // 按指定顺序排序 allLabels
            const labelOrder = [
                'TARGET_FIRST_APPEAR',
                'PF_TOO_LATE',
                'NO_TRIGGER',
                'NO_MD_LAST_ADDR_0',
                'NO_MD_LAST_ADDR_REPEAT',
                'PF_TOO_EARLY',
                'EVICTED_MD_CAPACITY',
                'EVICTED_MD_CONFLICT'
            ];
            // 先按 labelOrder 排序，其余的按原顺序追加
            const allLabelsArr = Array.from(allLabels);
            allLabels = labelOrder.concat(allLabelsArr.filter(l => !labelOrder.includes(l)));
            if (allData.length === 0) {
                alert('没有任何实验结果数据可用于绘图！');
                return;
            }
            // 归一化每个文件的各label数据为比例
            const normData = allData.map(d => {
                const total = d.data.reduce((a, b) => a + b, 0) || 1;
                return allLabels.map(label => {
                    const i = d.labels.indexOf(label);
                    return i >= 0 ? d.data[i] / total : 0;
                });
            });
            const datasets = allLabels.map((label, idx) => ({
                label,
                data: normData.map(row => row[idx]),
                backgroundColor: [
                    '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#C9CBCF', '#B2DFDB', '#F06292', '#FFD54F', '#81C784', '#BA68C8'
                ][idx % 12],
                stack: 'stack1',
            }));
            // 计算分隔线位置和 set 名
            const separators = [];
            let acc = 0;
            const setLabels = [];
            for (const g of grouped) {
                if (acc > 0) separators.push(acc - 0.5);
                setLabels.push({ name: g.set, pos: acc + g.traces.length / 2 });
                acc += g.traces.length;
            }
            // 每次重绘都彻底删除原有 canvas 并新建，防止变量和事件冲突
            if (window.barChartObj) window.barChartObj.destroy();
            const oldCanvas = document.getElementById('barChart');
            if (oldCanvas) {
                const parent = oldCanvas.parentNode;
                parent.removeChild(oldCanvas);
                const newCanvas = document.createElement('canvas');
                newCanvas.id = 'barChart';
                newCanvas.height = 800;
                newCanvas.style.width = '100%';
                parent.appendChild(newCanvas);
            }
            const barCanvas = document.getElementById('barChart');
            const ctx = barCanvas.getContext('2d');
            window.barChartObj = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: allData.map(d => d.file),
                    datasets: datasets
                },
                options: {
                    responsive: false,
                    plugins: {
                        legend: { position: 'top', align: 'start', labels: { boxWidth: 20, boxHeight: 20, padding: 16 } },
                        title: { display: true, text: '所有实验结果堆叠条形图' }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                callback: function(value, idx) {
                                    return this.getLabelForValue(idx);
                                },
                                autoSkip: false,
                                maxRotation: 90,
                                minRotation: 60
                            }
                        },
                        y: { stacked: true, max: 1.1 }
                    }
                },
                plugins: [{
                    id: 'setLabelAndSeparatorPlugin',
                    afterDraw: chart => {
                        // 在 x 轴下方绘制 set 名
                        const { ctx, chartArea, scales } = chart;
                        ctx.save();
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = '#333';
                        setLabels.forEach(({ name, pos }) => {
                            const x = scales.x.getPixelForValue(pos - 0.5);
                            ctx.fillText(name, x, chartArea.bottom - 550);
                        });
                        // 手动画分隔线
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 6]);
                        separators.forEach(v => {
                            const x = scales.x.getPixelForValue(v);
                            ctx.beginPath();
                            ctx.moveTo(x, chartArea.top);
                            ctx.lineTo(x, chartArea.bottom);
                            ctx.stroke();
                        });
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                }]
            });
            // 支持点击 bar 切换饼图
            barCanvas.onclick = function(evt) {
                const points = window.barChartObj.getElementsAtEventForMode(evt, 'index', { intersect: false }, true);
                if (points && points.length > 0) {
                    const idx = points[0].index;
                    const t = allData[idx].file;
                    const f = fileMap[t.toLowerCase()];
                    fetchResultData(f).then(text => {
                        const { labels, data } = parseResultData(text);
                        renderPieChart(labels, data, t);
                    });
                }
            };
            window.lastBarFiles = files;
        }
        async function main() {
            const fileListDiv = document.getElementById('fileList');
            const files = await fetchResultFiles();
            fileListDiv.innerHTML = files.map(f => `<button onclick="loadFile('${f}')">${f}</button>`).join(' ');
            if (files.length > 0) loadFile(files[0]);
            if (files.length > 0) renderBarChart(files);
            // 初始加载流程图
            refreshFlowGraph();
        }
        async function loadFile(filename) {
            const text = await fetchResultData(filename);
            const { labels, data } = parseResultData(text);
            // 提取 trace 名（去除 _breif.txt 或 .txt 后缀）
            let traceName = filename.replace(/_breif\.txt$/i, '').replace(/\.txt$/i, '');
            renderPieChart(labels, data, traceName);
            // 切换流程图
            refreshFlowGraph(traceName);
        }
        main();
    </script>
</body>
</html>
